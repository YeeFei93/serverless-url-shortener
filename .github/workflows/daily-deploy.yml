name: Daily AWS Resource Deployment (8AM Singapore Time)

on:
  # Run daily at 8:00 AM Singapore Time (00:00 UTC), including weekends
  schedule:
    - cron: '0 0 * * *'
  
  # Allow manual trigger for testing
  workflow_dispatch:
    inputs:
      destroy_first:
        description: 'Destroy existing resources first'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.5.0

jobs:
  deploy:
    name: Deploy Serverless URL Shortener (8AM SGT)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Build Lambda packages
      run: |
        chmod +x ./build.sh
        ./build.sh

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Clean up existing conflicting resources
      run: |
        echo "üßπ Cleaning up existing AWS resources that might conflict..."
        
        # Get AWS Account ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        
        # 1. Clean up S3 bucket and its contents
        echo "Cleaning up S3 bucket..."
        if aws s3 ls s3://yee-fei-url-shortener-frontend 2>/dev/null; then
          echo "Found existing S3 bucket, emptying and deleting..."
          aws s3 rm s3://yee-fei-url-shortener-frontend --recursive || true
          aws s3 rb s3://yee-fei-url-shortener-frontend --force || true
          echo "‚úÖ S3 bucket cleaned up"
        else
          echo "‚úÖ No existing S3 bucket found"
        fi
        
        # 2. Clean up IAM policy
        echo "Cleaning up IAM policy..."
        POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/url-shortener-lambda-enhanced"
        if aws iam get-policy --policy-arn "$POLICY_ARN" 2>/dev/null; then
          echo "Found existing IAM policy, detaching and deleting..."
          # Detach from any roles/users/groups
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyRoles[].RoleName' --output text | xargs -r -I {} aws iam detach-role-policy --role-name {} --policy-arn "$POLICY_ARN" || true
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyUsers[].UserName' --output text | xargs -r -I {} aws iam detach-user-policy --user-name {} --policy-arn "$POLICY_ARN" || true
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyGroups[].GroupName' --output text | xargs -r -I {} aws iam detach-group-policy --group-name {} --policy-arn "$POLICY_ARN" || true
          # Delete the policy
          aws iam delete-policy --policy-arn "$POLICY_ARN" || true
          echo "‚úÖ IAM policy cleaned up"
        else
          echo "‚úÖ No existing IAM policy found"
        fi
        
        # 3. Clean up CloudFront distributions (enhanced with deletion)
        echo "Cleaning up CloudFront distributions..."
        
        # Check for distributions with our CNAMEs
        for domain in "ui.sctp-sandbox.com" "short.sctp-sandbox.com"; do
          echo "Looking for CloudFront distribution with CNAME: $domain"
          
          CF_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Aliases.Items && contains(Aliases.Items, '$domain')].Id | [0]" --output text 2>/dev/null || echo "None")
          
          if [ "$CF_ID" != "None" ] && [ -n "$CF_ID" ]; then
            echo "Found existing CloudFront distribution for $domain: $CF_ID"
            
            # Check if it's already disabled
            ENABLED=$(aws cloudfront get-distribution --id "$CF_ID" --query 'Distribution.DistributionConfig.Enabled' --output text 2>/dev/null || echo "false")
            
            if [ "$ENABLED" = "true" ]; then
              echo "Disabling CloudFront distribution $CF_ID..."
              # Get current config
              aws cloudfront get-distribution-config --id "$CF_ID" > /tmp/cf-config-$CF_ID.json
              ETAG=$(jq -r '.ETag' /tmp/cf-config-$CF_ID.json)
              # Disable the distribution
              jq '.DistributionConfig.Enabled = false' /tmp/cf-config-$CF_ID.json > /tmp/cf-config-disabled-$CF_ID.json
              aws cloudfront update-distribution --id "$CF_ID" --distribution-config file:///tmp/cf-config-disabled-$CF_ID.json --if-match "$ETAG" || true
              echo "‚è≥ CloudFront distribution $CF_ID is being disabled..."
              
              # Wait for distribution to be disabled
              echo "Waiting for CloudFront distribution to be disabled..."
              aws cloudfront wait distribution-deployed --id "$CF_ID" || true
              
              # Now try to delete it
              echo "Attempting to delete CloudFront distribution $CF_ID..."
              CURRENT_ETAG=$(aws cloudfront get-distribution --id "$CF_ID" --query 'ETag' --output text 2>/dev/null || echo "")
              if [ ! -z "$CURRENT_ETAG" ]; then
                aws cloudfront delete-distribution --id "$CF_ID" --if-match "$CURRENT_ETAG" || true
                echo "‚úÖ CloudFront distribution $CF_ID deletion initiated"
              fi
            else
              echo "CloudFront distribution $CF_ID is already disabled, attempting deletion..."
              CURRENT_ETAG=$(aws cloudfront get-distribution --id "$CF_ID" --query 'ETag' --output text 2>/dev/null || echo "")
              if [ ! -z "$CURRENT_ETAG" ]; then
                aws cloudfront delete-distribution --id "$CF_ID" --if-match "$CURRENT_ETAG" || true
                echo "‚úÖ CloudFront distribution $CF_ID deletion initiated"
              fi
            fi
          else
            echo "‚úÖ No existing CloudFront distribution found for $domain"
          fi
        done
        
        # 4. Clean up API Gateway custom domain
        echo "Cleaning up API Gateway custom domain..."
        if aws apigatewayv2 get-domain-name --domain-name "short.sctp-sandbox.com" 2>/dev/null; then
          echo "Found existing API Gateway custom domain, deleting..."
          aws apigatewayv2 delete-domain-name --domain-name "short.sctp-sandbox.com" || true
          echo "‚úÖ API Gateway custom domain cleaned up"
        else
          echo "‚úÖ No existing API Gateway custom domain found"
        fi
        
        # 5. Clean up Route53 DNS validation records (only for our specific domains)
        echo "Cleaning up Route53 DNS validation records for our domains..."
        ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='sctp-sandbox.com.'].Id | [0]" --output text | cut -d'/' -f3)
        if [ "$ZONE_ID" != "None" ] && [ -n "$ZONE_ID" ]; then
          # Only delete validation records for our specific domains
          for domain in "ui.sctp-sandbox.com" "short.sctp-sandbox.com"; do
            echo "Looking for validation records for $domain..."
            
            # Find validation CNAME records that end with our domain
            aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" --query "ResourceRecordSets[?Type=='CNAME' && starts_with(Name, '_') && ends_with(Name, '.$domain.')]" --output json | jq -c '.[]' | while read -r record; do
              RECORD_NAME=$(echo "$record" | jq -r '.Name')
              RECORD_TYPE=$(echo "$record" | jq -r '.Type')
              RECORD_TTL=$(echo "$record" | jq -r '.TTL')
              RECORD_VALUE=$(echo "$record" | jq -r '.ResourceRecords[0].Value')
              
              echo "Deleting validation record for $domain: $RECORD_NAME"
              
              # Create changeset JSON directly with jq
              jq -n \
                --arg name "$RECORD_NAME" \
                --arg type "$RECORD_TYPE" \
                --argjson ttl "$RECORD_TTL" \
                --arg value "$RECORD_VALUE" \
                '{
                  "Changes": [{
                    "Action": "DELETE",
                    "ResourceRecordSet": {
                      "Name": $name,
                      "Type": $type,
                      "TTL": $ttl,
                      "ResourceRecords": [{"Value": $value}]
                    }
                  }]
                }' > /tmp/delete-record.json
              
              aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch file:///tmp/delete-record.json || true
            done
          done
          echo "‚úÖ DNS validation records for our domains cleaned up"
        else
          echo "‚úÖ No hosted zone found or no records to clean"
        fi
        
        # 6. Clean up Route53 A records for our domains
        echo "Cleaning up Route53 A records for our domains..."
        ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='sctp-sandbox.com.'].Id | [0]" --output text | cut -d'/' -f3)
        if [ "$ZONE_ID" != "None" ] && [ -n "$ZONE_ID" ]; then
          for domain in "ui.sctp-sandbox.com" "short.sctp-sandbox.com"; do
            echo "Looking for A record for $domain..."
            
            # Find A records for our specific domains
            RECORD=$(aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" --query "ResourceRecordSets[?Type=='A' && Name=='$domain.']" --output json | jq -c '.[0]' 2>/dev/null)
            
            if [ "$RECORD" != "null" ] && [ "$RECORD" != "" ]; then
              echo "Found A record for $domain, deleting..."
              
              # Check if it's an alias record or regular A record
              if echo "$RECORD" | jq -e '.AliasTarget' > /dev/null; then
                # It's an alias record
                ALIAS_TARGET=$(echo "$RECORD" | jq -r '.AliasTarget.DNSName')
                ALIAS_ZONE=$(echo "$RECORD" | jq -r '.AliasTarget.HostedZoneId')
                EVALUATE_HEALTH=$(echo "$RECORD" | jq -r '.AliasTarget.EvaluateTargetHealth')
                
                jq -n \
                  --arg name "$domain." \
                  --arg alias_target "$ALIAS_TARGET" \
                  --arg alias_zone "$ALIAS_ZONE" \
                  --argjson evaluate_health "$EVALUATE_HEALTH" \
                  '{
                    "Changes": [{
                      "Action": "DELETE",
                      "ResourceRecordSet": {
                        "Name": $name,
                        "Type": "A",
                        "AliasTarget": {
                          "DNSName": $alias_target,
                          "HostedZoneId": $alias_zone,
                          "EvaluateTargetHealth": $evaluate_health
                        }
                      }
                    }]
                  }' > /tmp/delete-a-record.json
              else
                # It's a regular A record
                RECORD_TTL=$(echo "$RECORD" | jq -r '.TTL')
                RECORD_VALUES=$(echo "$RECORD" | jq -c '.ResourceRecords')
                
                jq -n \
                  --arg name "$domain." \
                  --argjson ttl "$RECORD_TTL" \
                  --argjson values "$RECORD_VALUES" \
                  '{
                    "Changes": [{
                      "Action": "DELETE",
                      "ResourceRecordSet": {
                        "Name": $name,
                        "Type": "A",
                        "TTL": $ttl,
                        "ResourceRecords": $values
                      }
                    }]
                  }' > /tmp/delete-a-record.json
              fi
              
              aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch file:///tmp/delete-a-record.json || true
              echo "‚úÖ A record for $domain deleted"
            else
              echo "‚úÖ No A record found for $domain"
            fi
          done
        fi
        
        # 7. Clean up CloudWatch query definitions
        echo "Cleaning up CloudWatch query definitions..."
        for query_name in "url-shortener-error-analysis" "url-shortener-performance-analysis"; do
          echo "Checking for query definition: $query_name"
          
          # Get query definition
          QUERY_DEF=$(aws logs describe-query-definitions --query-definition-name-prefix "$query_name" --query "queryDefinitions[?name=='$query_name']" --output json 2>/dev/null || echo "[]")
          
          if [ "$(echo "$QUERY_DEF" | jq length)" -gt 0 ]; then
            echo "Found query definition $query_name, deleting..."
            aws logs delete-query-definition --query-definition-id "$(echo "$QUERY_DEF" | jq -r '.[0].queryDefinitionId')" || true
            echo "‚úÖ Query definition $query_name deleted"
          else
            echo "‚úÖ No query definition found for $query_name"
          fi
        done
        
        # 8. Clean up existing Lambda functions
        echo "Cleaning up existing Lambda functions..."
        for function_name in "shorten_url" "redirect_url" "options_handler"; do
          echo "Checking for existing Lambda function: $function_name"
          
          if aws lambda get-function --function-name "$function_name" 2>/dev/null; then
            echo "Found existing Lambda function $function_name, deleting..."
            aws lambda delete-function --function-name "$function_name" || true
            echo "‚úÖ Lambda function $function_name deleted"
          else
            echo "‚úÖ No existing Lambda function found: $function_name"
          fi
        done
        
        # 9. Clean up existing DynamoDB table
        echo "Cleaning up existing DynamoDB table..."
        TABLE_NAME="UrlTable"
        if aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null; then
          echo "Found existing DynamoDB table $TABLE_NAME, deleting..."
          aws dynamodb delete-table --table-name "$TABLE_NAME" || true
          echo "‚è≥ Waiting for DynamoDB table deletion..."
          aws dynamodb wait table-not-exists --table-name "$TABLE_NAME" || true
          echo "‚úÖ DynamoDB table $TABLE_NAME deleted"
        else
          echo "‚úÖ No existing DynamoDB table found: $TABLE_NAME"
        fi
        
        # 10. Clean up existing API Gateway
        echo "Cleaning up existing API Gateway..."
        API_NAME="url-shortener-api"
        API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_NAME'].ApiId | [0]" --output text 2>/dev/null || echo "None")
        if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
          echo "Found existing API Gateway $API_NAME with ID: $API_ID, deleting..."
          aws apigatewayv2 delete-api --api-id "$API_ID" || true
          echo "‚úÖ API Gateway $API_NAME deleted"
        else
          echo "‚úÖ No existing API Gateway found: $API_NAME"
        fi
        
        # 11. Clean up CloudWatch alarms
        echo "Cleaning up CloudWatch alarms..."
        for alarm_name in "url-shortener-lambda-errors" "url-shortener-api-errors" "url-shortener-dynamodb-errors" "url-shortener-dynamodb-throttles"; do
          echo "Checking for alarm: $alarm_name"
          if aws cloudwatch describe-alarms --alarm-names "$alarm_name" --query 'MetricAlarms[0]' --output text 2>/dev/null | grep -v "None"; then
            echo "Found existing alarm $alarm_name, deleting..."
            aws cloudwatch delete-alarms --alarm-names "$alarm_name" || true
            echo "‚úÖ CloudWatch alarm $alarm_name deleted"
          else
            echo "‚úÖ No existing alarm found: $alarm_name"
          fi
        done
        
        # 12. Clean up CloudWatch Log Groups
        echo "Cleaning up CloudWatch Log Groups..."
        for log_group in "/aws/lambda/url-shortener-shorten" "/aws/lambda/url-shortener-redirect" "/aws/lambda/url-shortener-options"; do
          echo "Checking for log group: $log_group"
          if aws logs describe-log-groups --log-group-name-prefix "$log_group" --query 'logGroups[?logGroupName==`'$log_group'`]' --output text 2>/dev/null | grep -q "$log_group"; then
            echo "Found existing log group $log_group, deleting..."
            aws logs delete-log-group --log-group-name "$log_group" || true
            echo "‚úÖ CloudWatch log group $log_group deleted"
          else
            echo "‚úÖ No existing log group found: $log_group"
          fi
        done
        
        # 13. Clean up XRay Sampling Rule
        echo "Cleaning up XRay Sampling Rule..."
        SAMPLING_RULE_NAME="url-shortener-sampling"
        if aws xray get-sampling-rules --query "SamplingRuleRecords[?SamplingRule.RuleName=='$SAMPLING_RULE_NAME']" --output text 2>/dev/null | grep -q "$SAMPLING_RULE_NAME"; then
          echo "Found existing XRay sampling rule $SAMPLING_RULE_NAME, deleting..."
          aws xray delete-sampling-rule --rule-name "$SAMPLING_RULE_NAME" || true
          echo "‚úÖ XRay sampling rule $SAMPLING_RULE_NAME deleted"
        else
          echo "‚úÖ No existing XRay sampling rule found: $SAMPLING_RULE_NAME"
        fi
        
        # 14. Clean up WAFv2 Web ACL
        echo "Cleaning up WAFv2 Web ACL..."
        WEB_ACL_NAME="url-shortener-api-protection"
        WEB_ACL_ID=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region us-east-1 --query "WebACLs[?Name=='$WEB_ACL_NAME'].Id | [0]" --output text 2>/dev/null || echo "None")
        if [ "$WEB_ACL_ID" != "None" ] && [ -n "$WEB_ACL_ID" ]; then
          echo "Found existing WAFv2 Web ACL $WEB_ACL_NAME with ID: $WEB_ACL_ID, deleting..."
          
          # First, get the lock token
          LOCK_TOKEN=$(aws wafv2 get-web-acl --scope CLOUDFRONT --region us-east-1 --id "$WEB_ACL_ID" --name "$WEB_ACL_NAME" --query 'LockToken' --output text 2>/dev/null || echo "")
          
          if [ ! -z "$LOCK_TOKEN" ]; then
            aws wafv2 delete-web-acl --scope CLOUDFRONT --region us-east-1 --id "$WEB_ACL_ID" --name "$WEB_ACL_NAME" --lock-token "$LOCK_TOKEN" || true
            echo "‚úÖ WAFv2 Web ACL $WEB_ACL_NAME deleted"
          else
            echo "‚ö†Ô∏è Could not get lock token for WAFv2 Web ACL $WEB_ACL_NAME"
          fi
        else
          echo "‚úÖ No existing WAFv2 Web ACL found: $WEB_ACL_NAME"
        fi
        
        # 15. Clean up ACM certificates
        echo "Cleaning up ACM certificates..."
        for domain in "ui.sctp-sandbox.com" "short.sctp-sandbox.com"; do
          CERT_ARN=$(aws acm list-certificates --region us-east-1 --query "CertificateSummaryList[?DomainName=='$domain'].CertificateArn | [0]" --output text 2>/dev/null || echo "None")
          if [ "$CERT_ARN" != "None" ] && [ -n "$CERT_ARN" ]; then
            echo "Found certificate for $domain, checking if it's in use..."
            IN_USE=$(aws acm describe-certificate --region us-east-1 --certificate-arn "$CERT_ARN" --query 'Certificate.InUseBy' --output text 2>/dev/null || echo "[]")
            if [ "$IN_USE" = "[]" ] || [ "$IN_USE" = "None" ]; then
              echo "Certificate not in use, deleting..."
              aws acm delete-certificate --region us-east-1 --certificate-arn "$CERT_ARN" || true
              echo "‚úÖ Certificate for $domain deleted"
            else
              echo "‚ö†Ô∏è Certificate for $domain is in use, skipping deletion"
            fi
          else
            echo "‚úÖ No certificate found for $domain"
          fi
        done
        
        # Wait a bit for AWS eventual consistency
        echo "‚è≥ Waiting 30 seconds for AWS eventual consistency..."
        sleep 30
        
        echo "‚úÖ Resource cleanup completed!"

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -out=tfplan

    - name: Optional - Destroy existing resources
      if: ${{ github.event.inputs.destroy_first == 'true' }}
      working-directory: terraform
      run: terraform destroy -auto-approve

    - name: Terraform Apply
      working-directory: terraform
      run: terraform apply -auto-approve tfplan

    - name: Output deployment info
      working-directory: terraform
      run: |
        echo "## Deployment Complete! üöÄ" >> $GITHUB_STEP_SUMMARY
        echo "### Infrastructure Outputs:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        terraform output >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        
        echo "### Deployment Time:" >> $GITHUB_STEP_SUMMARY
        echo "$(date) (Deployed at 8:00 AM Singapore Time)" >> $GITHUB_STEP_SUMMARY

    - name: Verify deployment health
      run: |
        # Wait a bit for resources to be fully ready
        sleep 30
        
        # Get the API endpoint from terraform output
        API_ENDPOINT=$(cd terraform && terraform output -raw api_gateway_url 2>/dev/null || echo "")
        
        if [ ! -z "$API_ENDPOINT" ]; then
          echo "Testing API endpoint: $API_ENDPOINT"
          
          # Test OPTIONS request (CORS preflight)
          curl -X OPTIONS -i "$API_ENDPOINT/shorten" || true
          
          echo "‚úÖ Deployment health check completed"
        else
          echo "‚ö†Ô∏è Could not retrieve API endpoint for health check"
        fi

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()  # Run even if deploy fails
    
    steps:
    - name: Send success notification
      if: needs.deploy.result == 'success'
      run: |
        echo "‚úÖ Daily deployment completed successfully at $(date)"
        echo "üá∏üá¨ Deployed at 8:00 AM Singapore Time (including weekends)"
        # Add webhook/email notification here if needed
        
    - name: Send failure notification  
      if: needs.deploy.result == 'failure'
      run: |
        echo "‚ùå Daily deployment failed at $(date)"
        echo "üá∏üá¨ Failed during 8:00 AM Singapore Time deployment"
        # Add webhook/email notification here if needed
