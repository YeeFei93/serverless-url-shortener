name: Daily AWS Resource Deployment (8AM Singapore Time)

on:
  # Run daily at 8:00 AM Singapore Time (00:00 UTC), including weekends
  schedule:
    - cron: '0 0 * * *'
  
  # Allow manual trigger for testing
  workflow_dispatch:
    inputs:
      destroy_first:
        description: 'Destroy existing resources first'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.5.0

jobs:
  deploy:
    name: Deploy Serverless URL Shortener (8AM SGT)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Build Lambda Docker images and push to ECR
      run: |
        chmod +x ./scripts/docker-build.sh
        ./scripts/docker-build.sh

    - name: Terraform Init
      working-directory: terraform
      run: terraform init

    - name: Setup cleanup environment
      run: |
        echo "🧹 Setting up cleanup environment..."
        
        # Get AWS Account ID and export for other steps
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        
        # Define common resource names
        echo "S3_BUCKET_NAME=yee-fei-url-shortener-frontend" >> $GITHUB_ENV
        echo "IAM_POLICY_NAME=url-shortener-lambda-enhanced" >> $GITHUB_ENV
        echo "DYNAMODB_TABLE_NAME=UrlTable" >> $GITHUB_ENV
        echo "XRAY_SAMPLING_RULE_NAME=url-shortener-sampling" >> $GITHUB_ENV
        echo "WAF_WEB_ACL_NAME=url-shortener-api-protection" >> $GITHUB_ENV
        echo "API_DOMAIN_NAME=short.sctp-sandbox.com" >> $GITHUB_ENV
        echo "FRONTEND_DOMAIN_NAME=ui.sctp-sandbox.com" >> $GITHUB_ENV
        
        echo "✅ Cleanup environment setup completed"

    - name: Clean S3 resources
      run: |
        echo "🗄️ Cleaning up S3 resources..."
        
        if aws s3 ls s3://$S3_BUCKET_NAME 2>/dev/null; then
          echo "Found existing S3 bucket, emptying and deleting..."
          aws s3 rm s3://$S3_BUCKET_NAME --recursive || true
          aws s3 rb s3://$S3_BUCKET_NAME --force || true
          echo "✅ S3 bucket $S3_BUCKET_NAME cleaned up"
        else
          echo "✅ No existing S3 bucket found: $S3_BUCKET_NAME"
        fi

    - name: Clean IAM resources
      run: |
        echo "🔐 Cleaning up IAM resources..."
        
        POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/$IAM_POLICY_NAME"
        if aws iam get-policy --policy-arn "$POLICY_ARN" 2>/dev/null; then
          echo "Found existing IAM policy, detaching and deleting..."
          
          # Detach from any roles/users/groups
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyRoles[].RoleName' --output text | xargs -r -I {} aws iam detach-role-policy --role-name {} --policy-arn "$POLICY_ARN" || true
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyUsers[].UserName' --output text | xargs -r -I {} aws iam detach-user-policy --user-name {} --policy-arn "$POLICY_ARN" || true
          aws iam list-entities-for-policy --policy-arn "$POLICY_ARN" --query 'PolicyGroups[].GroupName' --output text | xargs -r -I {} aws iam detach-group-policy --group-name {} --policy-arn "$POLICY_ARN" || true
          
          # Delete the policy
          aws iam delete-policy --policy-arn "$POLICY_ARN" || true
          echo "✅ IAM policy $IAM_POLICY_NAME cleaned up"
        else
          echo "✅ No existing IAM policy found: $IAM_POLICY_NAME"
        fi

    - name: Clean Lambda functions
      run: |
        echo "⚡ Cleaning up Lambda functions..."
        
        # List of Lambda functions to clean up
        LAMBDA_FUNCTIONS=("shorten_url" "redirect_url" "options_handler")
        
        for FUNCTION_NAME in "${LAMBDA_FUNCTIONS[@]}"; do
          echo "Checking Lambda function: $FUNCTION_NAME"
          
          if aws lambda get-function --function-name "$FUNCTION_NAME" > /dev/null 2>&1; then
            echo "Found existing Lambda function $FUNCTION_NAME, deleting..."
            
            if aws lambda delete-function --function-name "$FUNCTION_NAME" 2>/dev/null; then
              echo "✅ Successfully deleted Lambda function $FUNCTION_NAME"
            else
              echo "⚠️ Failed to delete Lambda function $FUNCTION_NAME (may be in use)"
            fi
          else
            echo "✅ No existing Lambda function found: $FUNCTION_NAME"
          fi
        done
        
        echo "🏁 Lambda functions cleanup completed"

    - name: Clean DynamoDB table
      run: |
        echo "�️ Cleaning up DynamoDB table..."
        
        if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE_NAME" > /dev/null 2>&1; then
          echo "Found existing DynamoDB table $DYNAMODB_TABLE_NAME, deleting..."
          if aws dynamodb delete-table --table-name "$DYNAMODB_TABLE_NAME" 2>/dev/null; then
            echo "✅ Successfully initiated deletion of DynamoDB table $DYNAMODB_TABLE_NAME"
            # Wait a bit for deletion to start
            sleep 10
          else
            echo "⚠️ Failed to delete DynamoDB table $DYNAMODB_TABLE_NAME"
          fi
        else
          echo "✅ No existing DynamoDB table found: $DYNAMODB_TABLE_NAME"
        fi

    - name: Clean CloudWatch resources
      run: |
        echo "� Cleaning up CloudWatch resources..."
        
        # Clean up Log Groups
        LOG_GROUPS=("/aws/lambda/url-shortener-shorten" "/aws/lambda/url-shortener-redirect" "/aws/lambda/url-shortener-options")
        
        for LOG_GROUP in "${LOG_GROUPS[@]}"; do
          echo "Checking CloudWatch Log Group: $LOG_GROUP"
          
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query "logGroups[?logGroupName=='$LOG_GROUP']" --output text | grep -q "$LOG_GROUP"; then
            echo "Found existing log group $LOG_GROUP, deleting..."
            if aws logs delete-log-group --log-group-name "$LOG_GROUP" 2>/dev/null; then
              echo "✅ Successfully deleted log group $LOG_GROUP"
            else
              echo "⚠️ Failed to delete log group $LOG_GROUP"
            fi
          else
            echo "✅ No existing log group found: $LOG_GROUP"
          fi
        done
        
        # Clean up query definitions
        echo "Cleaning up CloudWatch query definitions..."
        for query_name in "url-shortener-error-analysis" "url-shortener-performance-analysis"; do
          echo "Checking for query definition: $query_name"
          
          QUERY_DEF=$(aws logs describe-query-definitions --query-definition-name-prefix "$query_name" --query "queryDefinitions[?name=='$query_name']" --output json 2>/dev/null || echo "[]")
          
          if [ "$(echo "$QUERY_DEF" | jq length)" -gt 0 ]; then
            echo "Found query definition $query_name, deleting..."
            aws logs delete-query-definition --query-definition-id "$(echo "$QUERY_DEF" | jq -r '.[0].queryDefinitionId')" || true
            echo "✅ Query definition $query_name deleted"
          else
            echo "✅ No query definition found for $query_name"
          fi
        done

    - name: Clean X-Ray resources
      run: |
        echo "� Cleaning up X-Ray resources..."
        
        # Check if X-Ray sampling rule exists by listing all rules and filtering
        if aws xray get-sampling-rules --query "SamplingRuleRecords[?SamplingRule.RuleName=='$XRAY_SAMPLING_RULE_NAME'].SamplingRule.RuleName" --output text 2>/dev/null | grep -q "$XRAY_SAMPLING_RULE_NAME"; then
          echo "Found existing X-Ray sampling rule $XRAY_SAMPLING_RULE_NAME, deleting..."
          # Add timeout to avoid hanging
          if timeout 30 aws xray delete-sampling-rule --rule-name "$XRAY_SAMPLING_RULE_NAME" 2>/dev/null; then
            echo "✅ Successfully deleted X-Ray sampling rule $XRAY_SAMPLING_RULE_NAME"
          else
            echo "⚠️ Failed to delete X-Ray sampling rule $XRAY_SAMPLING_RULE_NAME (timeout or error)"
          fi
        else
          echo "✅ No existing X-Ray sampling rule found: $XRAY_SAMPLING_RULE_NAME"
        fi

    - name: Clean WAF resources
      run: |
        echo "�️ Cleaning up WAF resources..."
        
        WEB_ACL_SCOPE="REGIONAL"
        
        # Get Web ACL details if it exists
        WEB_ACL_INFO=$(aws wafv2 list-web-acls --scope "$WEB_ACL_SCOPE" --query "WebACLs[?Name=='$WAF_WEB_ACL_NAME']" --output json 2>/dev/null || echo "[]")
        
        if [ "$(echo "$WEB_ACL_INFO" | jq length)" -gt 0 ]; then
          WEB_ACL_ID=$(echo "$WEB_ACL_INFO" | jq -r '.[0].Id')
          echo "Found existing WAF Web ACL $WAF_WEB_ACL_NAME with ID: $WEB_ACL_ID"
          
          # Get fresh lock token for deletion (lock tokens change frequently)
          FRESH_WEB_ACL_INFO=$(aws wafv2 get-web-acl --scope "$WEB_ACL_SCOPE" --id "$WEB_ACL_ID" --name "$WAF_WEB_ACL_NAME" 2>/dev/null || echo "{}")
          LOCK_TOKEN=$(echo "$FRESH_WEB_ACL_INFO" | jq -r '.LockToken // empty')
          
          if [ -n "$LOCK_TOKEN" ]; then
            echo "Attempting to delete WAF Web ACL with fresh lock token..."
            if aws wafv2 delete-web-acl --scope "$WEB_ACL_SCOPE" --id "$WEB_ACL_ID" --name "$WAF_WEB_ACL_NAME" --lock-token "$LOCK_TOKEN" 2>/dev/null; then
              echo "✅ Successfully deleted WAF Web ACL $WAF_WEB_ACL_NAME"
            else
              echo "⚠️ Failed to delete WAF Web ACL $WAF_WEB_ACL_NAME (may be associated with resources)"
            fi
          else
            echo "⚠️ Could not get lock token for WAF Web ACL $WAF_WEB_ACL_NAME"
          fi
        else
          echo "✅ No existing WAF Web ACL found: $WAF_WEB_ACL_NAME"
        fi

    - name: Clean CloudFront distributions
      run: |
        echo "☁️ Starting CloudFront distributions cleanup..."
        
        # Function to wait for CloudFront distribution status
        wait_for_cloudfront_status() {
          local cf_id=$1
          local target_status=$2
          local max_wait_minutes=$3
          local wait_seconds=0
          local max_wait_seconds=$((max_wait_minutes * 60))
          
          echo "⏳ Waiting for CloudFront distribution $cf_id to reach status: $target_status (max ${max_wait_minutes}min)"
          
          while [ $wait_seconds -lt $max_wait_seconds ]; do
            local current_status=$(aws cloudfront get-distribution --id "$cf_id" --query 'Distribution.Status' --output text 2>/dev/null || echo "NotFound")
            
            if [ "$current_status" = "$target_status" ]; then
              echo "✅ CloudFront distribution $cf_id is now $target_status"
              return 0
            elif [ "$current_status" = "NotFound" ]; then
              echo "✅ CloudFront distribution $cf_id no longer exists"
              return 0
            fi
            
            echo "   Status: $current_status (waiting ${wait_seconds}s/${max_wait_seconds}s)"
            sleep 30
            wait_seconds=$((wait_seconds + 30))
          done
          
          echo "⚠️ Timeout waiting for CloudFront distribution $cf_id to reach $target_status"
          return 1
        }
        
        # Check for distributions with our CNAMEs
        for domain in "$FRONTEND_DOMAIN_NAME" "$API_DOMAIN_NAME"; do
          echo "🔍 Looking for CloudFront distribution with CNAME: $domain"
          
          CF_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Aliases.Items && contains(Aliases.Items, '$domain')].Id | [0]" --output text 2>/dev/null || echo "None")
          
          if [ "$CF_ID" != "None" ] && [ -n "$CF_ID" ]; then
            echo "📍 Found existing CloudFront distribution for $domain: $CF_ID"
            
            # Get current distribution status and config
            DISTRIBUTION_INFO=$(aws cloudfront get-distribution --id "$CF_ID" 2>/dev/null || echo "{}")
            if [ "$DISTRIBUTION_INFO" = "{}" ]; then
              echo "✅ Distribution $CF_ID no longer exists"
              continue
            fi
            
            ENABLED=$(echo "$DISTRIBUTION_INFO" | jq -r '.Distribution.DistributionConfig.Enabled')
            STATUS=$(echo "$DISTRIBUTION_INFO" | jq -r '.Distribution.Status')
            
            echo "   Current status: $STATUS, Enabled: $ENABLED"
            
            # Step 1: Disable the distribution if it's enabled
            if [ "$ENABLED" = "true" ]; then
              echo "🔧 Disabling CloudFront distribution $CF_ID..."
              
              # Get current config and ETag
              aws cloudfront get-distribution-config --id "$CF_ID" > /tmp/cf-config-$CF_ID.json 2>/dev/null || continue
              ETAG=$(jq -r '.ETag' /tmp/cf-config-$CF_ID.json)
              
              # Create disabled config (extract only DistributionConfig part)
              jq '.DistributionConfig | .Enabled = false' /tmp/cf-config-$CF_ID.json > /tmp/cf-config-disabled-$CF_ID.json
              
              # Update the distribution
              if aws cloudfront update-distribution --id "$CF_ID" --distribution-config file:///tmp/cf-config-disabled-$CF_ID.json --if-match "$ETAG" 2>/dev/null; then
                echo "✅ Successfully initiated disable for distribution $CF_ID"
              else
                echo "⚠️ Failed to disable distribution $CF_ID, may already be in progress"
              fi
            fi
            
            # Step 2: Wait for distribution to be deployed (disabled state)
            if wait_for_cloudfront_status "$CF_ID" "Deployed" 15; then
              echo "🗑️ Attempting to delete CloudFront distribution $CF_ID..."
              
              # Get fresh ETag for deletion
              FRESH_ETAG=$(aws cloudfront get-distribution --id "$CF_ID" --query 'ETag' --output text 2>/dev/null || echo "")
              
              if [ -n "$FRESH_ETAG" ]; then
                if aws cloudfront delete-distribution --id "$CF_ID" --if-match "$FRESH_ETAG" 2>/dev/null; then
                  echo "✅ Successfully initiated deletion of distribution $CF_ID"
                else
                  echo "⚠️ Failed to delete distribution $CF_ID - may still have dependencies or invalid ETag"
                fi
              else
                echo "⚠️ Could not get fresh ETag for distribution $CF_ID"
              fi
            else
              echo "⚠️ Distribution $CF_ID did not reach Deployed status within timeout"
              echo "   This distribution may still cause CNAME conflicts"
            fi
            
            # Cleanup temp files
            rm -f /tmp/cf-config-$CF_ID.json /tmp/cf-config-disabled-$CF_ID.json
            
          else
            echo "✅ No existing CloudFront distribution found for $domain"
          fi
        done
        
        echo "🏁 CloudFront cleanup completed"
        echo "🏁 CloudFront cleanup completed"

    - name: Clean API Gateway resources
      run: |
        echo "🚪 Cleaning up API Gateway resources..."
        
        if aws apigatewayv2 get-domain-name --domain-name "$API_DOMAIN_NAME" 2>/dev/null; then
          echo "Found existing API Gateway custom domain, deleting..."
          aws apigatewayv2 delete-domain-name --domain-name "$API_DOMAIN_NAME" || true
          echo "✅ API Gateway custom domain cleaned up"
        else
          echo "✅ No existing API Gateway custom domain found: $API_DOMAIN_NAME"
        fi

    - name: Clean Route53 DNS records
      run: |
        echo "🌐 Cleaning up Route53 DNS records..."
        
        ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='sctp-sandbox.com.'].Id | [0]" --output text | cut -d'/' -f3)
        if [ "$ZONE_ID" != "None" ] && [ -n "$ZONE_ID" ]; then
          
          # Clean DNS validation records
          echo "Cleaning up DNS validation records for our domains..."
          for domain in "$FRONTEND_DOMAIN_NAME" "$API_DOMAIN_NAME"; do
            echo "Looking for validation records for $domain..."
            
            # Find validation CNAME records that end with our domain
            aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" --query "ResourceRecordSets[?Type=='CNAME' && starts_with(Name, '_') && ends_with(Name, '.$domain.')]" --output json | jq -c '.[]' | while read -r record; do
              RECORD_NAME=$(echo "$record" | jq -r '.Name')
              RECORD_TYPE=$(echo "$record" | jq -r '.Type')
              RECORD_TTL=$(echo "$record" | jq -r '.TTL')
              RECORD_VALUE=$(echo "$record" | jq -r '.ResourceRecords[0].Value')
              
              echo "Deleting validation record for $domain: $RECORD_NAME"
              
              # Create changeset JSON directly with jq
              jq -n \
                --arg name "$RECORD_NAME" \
                --arg type "$RECORD_TYPE" \
                --argjson ttl "$RECORD_TTL" \
                --arg value "$RECORD_VALUE" \
                '{
                  "Changes": [{
                    "Action": "DELETE",
                    "ResourceRecordSet": {
                      "Name": $name,
                      "Type": $type,
                      "TTL": $ttl,
                      "ResourceRecords": [{"Value": $value}]
                    }
                  }]
                }' > /tmp/delete-record.json
              
              aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch file:///tmp/delete-record.json || true
            done
          done
          
          # Clean A records
          echo "Cleaning up A records for our domains..."
          for domain in "$FRONTEND_DOMAIN_NAME" "$API_DOMAIN_NAME"; do
            echo "Looking for A record for $domain..."
            
            # Find A records for our specific domains
            RECORD=$(aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" --query "ResourceRecordSets[?Type=='A' && Name=='$domain.']" --output json | jq -c '.[0]' 2>/dev/null)
            
            if [ "$RECORD" != "null" ] && [ "$RECORD" != "" ]; then
              echo "Found A record for $domain, deleting..."
              
              # Check if it's an alias record or regular A record
              if echo "$RECORD" | jq -e '.AliasTarget' > /dev/null; then
                # It's an alias record
                ALIAS_TARGET=$(echo "$RECORD" | jq -r '.AliasTarget.DNSName')
                ALIAS_ZONE=$(echo "$RECORD" | jq -r '.AliasTarget.HostedZoneId')
                EVALUATE_HEALTH=$(echo "$RECORD" | jq -r '.AliasTarget.EvaluateTargetHealth')
                
                jq -n \
                  --arg name "$domain." \
                  --arg alias_target "$ALIAS_TARGET" \
                  --arg alias_zone "$ALIAS_ZONE" \
                  --argjson evaluate_health "$EVALUATE_HEALTH" \
                  '{
                    "Changes": [{
                      "Action": "DELETE",
                      "ResourceRecordSet": {
                        "Name": $name,
                        "Type": "A",
                        "AliasTarget": {
                          "DNSName": $alias_target,
                          "HostedZoneId": $alias_zone,
                          "EvaluateTargetHealth": $evaluate_health
                        }
                      }
                    }]
                  }' > /tmp/delete-a-record.json
              else
                # It's a regular A record
                RECORD_TTL=$(echo "$RECORD" | jq -r '.TTL')
                RECORD_VALUES=$(echo "$RECORD" | jq -c '.ResourceRecords')
                
                jq -n \
                  --arg name "$domain." \
                  --argjson ttl "$RECORD_TTL" \
                  --argjson values "$RECORD_VALUES" \
                  '{
                    "Changes": [{
                      "Action": "DELETE",
                      "ResourceRecordSet": {
                        "Name": $name,
                        "Type": "A",
                        "TTL": $ttl,
                        "ResourceRecords": $values
                      }
                    }]
                  }' > /tmp/delete-a-record.json
              fi
              
              aws route53 change-resource-record-sets --hosted-zone-id "$ZONE_ID" --change-batch file:///tmp/delete-a-record.json || true
              echo "✅ A record for $domain deleted"
            else
              echo "✅ No A record found for $domain"
            fi
          done
          
          echo "✅ DNS records cleaned up"
        else
          echo "✅ No hosted zone found or no records to clean"
        fi

    - name: Clean ACM certificates
      run: |
        echo "🔒 Cleaning up ACM certificates..."
        
        for domain in "$FRONTEND_DOMAIN_NAME" "$API_DOMAIN_NAME"; do
          CERT_ARN=$(aws acm list-certificates --region us-east-1 --query "CertificateSummaryList[?DomainName=='$domain'].CertificateArn | [0]" --output text 2>/dev/null || echo "None")
          if [ "$CERT_ARN" != "None" ] && [ -n "$CERT_ARN" ]; then
            echo "Found certificate for $domain, checking if it's in use..."
            IN_USE=$(aws acm describe-certificate --region us-east-1 --certificate-arn "$CERT_ARN" --query 'Certificate.InUseBy' --output text 2>/dev/null || echo "[]")
            if [ "$IN_USE" = "[]" ] || [ "$IN_USE" = "None" ]; then
              echo "Certificate not in use, deleting..."
              aws acm delete-certificate --region us-east-1 --certificate-arn "$CERT_ARN" || true
              echo "✅ Certificate for $domain deleted"
            else
              echo "⚠️ Certificate for $domain is in use, skipping deletion"
            fi
          else
            echo "✅ No certificate found for $domain"
          fi
        done

    - name: Final cleanup and consistency wait
      run: |
        echo "⏳ Final cleanup and AWS consistency wait..."
        
        # Wait for AWS eventual consistency and any remaining CloudFront operations
        echo "Waiting 60 seconds for AWS eventual consistency and CloudFront operations..."
        sleep 60
        
        echo "✅ Resource cleanup completed!"

    - name: Pre-deployment CloudFront verification
      run: |
        echo "🔍 Verifying no conflicting CloudFront distributions exist..."
        
        # Check for any remaining distributions with our CNAMEs
        for domain in "$FRONTEND_DOMAIN_NAME" "$API_DOMAIN_NAME"; do
          CF_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Aliases.Items && contains(Aliases.Items, '$domain')].Id | [0]" --output text 2>/dev/null || echo "None")
          
          if [ "$CF_ID" != "None" ] && [ -n "$CF_ID" ]; then
            ENABLED=$(aws cloudfront get-distribution --id "$CF_ID" --query 'Distribution.DistributionConfig.Enabled' --output text 2>/dev/null || echo "false")
            STATUS=$(aws cloudfront get-distribution --id "$CF_ID" --query 'Distribution.Status' --output text 2>/dev/null || echo "Unknown")
            
            echo "⚠️ WARNING: Found existing CloudFront distribution for $domain:"
            echo "   Distribution ID: $CF_ID"
            echo "   Enabled: $ENABLED"
            echo "   Status: $STATUS"
            
            if [ "$ENABLED" = "true" ] || [ "$STATUS" != "Deployed" ]; then
              echo "❌ This distribution may cause deployment conflicts!"
            else
              echo "ℹ️ Distribution is disabled and deployed - should be safe to proceed"
            fi
          else
            echo "✅ No conflicting CloudFront distribution found for $domain"
          fi
        done
        
        echo "🏁 CloudFront verification completed"

    - name: Terraform Plan
      working-directory: terraform
      run: terraform plan -out=tfplan

    - name: Optional - Destroy existing resources
      if: ${{ github.event.inputs.destroy_first == 'true' }}
      working-directory: terraform
      run: terraform destroy -auto-approve

    - name: Terraform Apply
      working-directory: terraform
      run: terraform apply -auto-approve tfplan

    - name: Output deployment info
      working-directory: terraform
      run: |
        echo "## Deployment Complete! 🚀" >> $GITHUB_STEP_SUMMARY
        echo "### Infrastructure Outputs:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        terraform output >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        
        echo "### Deployment Time:" >> $GITHUB_STEP_SUMMARY
        echo "$(date) (Deployed at 8:00 AM Singapore Time)" >> $GITHUB_STEP_SUMMARY

    - name: Verify deployment health
      run: |
        # Wait a bit for resources to be fully ready
        sleep 30
        
        # Get the API endpoint from terraform output
        API_ENDPOINT=$(cd terraform && terraform output -raw api_gateway_url 2>/dev/null || echo "")
        
        if [ ! -z "$API_ENDPOINT" ]; then
          echo "Testing API endpoint: $API_ENDPOINT"
          
          # Test OPTIONS request (CORS preflight)
          curl -X OPTIONS -i "$API_ENDPOINT/shorten" || true
          
          echo "✅ Deployment health check completed"
        else
          echo "⚠️ Could not retrieve API endpoint for health check"
        fi

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()  # Run even if deploy fails
    
    steps:
    - name: Send success notification
      if: needs.deploy.result == 'success'
      run: |
        echo "✅ Daily deployment completed successfully at $(date)"
        echo "🇸🇬 Deployed at 8:00 AM Singapore Time (including weekends)"
        # Add webhook/email notification here if needed
        
    - name: Send failure notification  
      if: needs.deploy.result == 'failure'
      run: |
        echo "❌ Daily deployment failed at $(date)"
        echo "🇸🇬 Failed during 8:00 AM Singapore Time deployment"
        # Add webhook/email notification here if needed
